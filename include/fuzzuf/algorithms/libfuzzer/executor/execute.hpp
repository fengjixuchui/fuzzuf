/*
 * fuzzuf
 * Copyright (C) 2021-2023 Ricerca Security
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/.
 */
/**
 * @file execute.hpp
 * @author Ricerca Security <fuzzuf-dev@ricsec.co.jp>
 */
#ifndef FUZZUF_INCLUDE_ALGORITHM_LIBFUZZER_EXECUTOR_EXECUTE_HPP
#define FUZZUF_INCLUDE_ALGORITHM_LIBFUZZER_EXECUTOR_EXECUTE_HPP
#include <algorithm>
#include <cctype>
#include <iterator>
#include <type_traits>

#include "fuzzuf/algorithms/libfuzzer/state/common_types.hpp"
#include "fuzzuf/algorithms/libfuzzer/state/input_info.hpp"
#include "fuzzuf/utils/range_traits.hpp"
#include "fuzzuf/utils/vfs/read_once.hpp"

namespace fuzzuf::algorithm::libfuzzer::executor {

/**
 * Run target with input, and acquire coverage,
 * outputs, execution result.
 *
 * @tparam Range Contiguous Range of std::uint8_t to pass input
 * @tparam Output Container of std::uint8_t to receive standard output
 * @tparam Cov Container of std::uint8_t to receive coverage
 * @tparam InputInfo Type of execution result
 * @tparam Executor Executor type
 * @param state LibFuzzer state object
 * @param corpus FullCorpus to add new execution result
 * @param range Input value that was passed to the executor
 * @param exec_result Reference to execution result to output detail of this
 * execution
 * @param executor Executor to run target
 * @param afl_coverage If True, coverage is retrived using GetAFLFeedback().
 * Otherwise coverage is retrived using GetBBFeedback().
 */
template <typename Range, typename Output, typename Cov, typename InputInfo,
          typename Executor>
auto Execute(Range &range, Output &output, Cov &cov, InputInfo &exec_result,
             Executor &executor, std::size_t executor_index, bool afl_coverage)
    -> std::enable_if_t<is_input_info_v<InputInfo> &&
                        utils::range::is_range_of_v<Range, std::uint8_t> &&
                        utils::range::has_data_v<Range> &&
                        utils::range::is_range_of_v<Output, std::uint8_t> &&
                        utils::range::is_range_of_v<Cov, std::uint8_t>> {
  const auto begin = std::chrono::high_resolution_clock::now();
  executor[executor_index].Run(range.data(),
                               fuzzuf::utils::range::rangeSize(range));
  const auto end = std::chrono::high_resolution_clock::now();
  exec_result.enabled = true;
  exec_result.time_of_unit =
      std::chrono::duration_cast<std::chrono::microseconds>(end - begin);
  exec_result.status =
      executor[executor_index].GetExitStatusFeedback().exit_reason;
  exec_result.signal = executor[executor_index].GetExitStatusFeedback().signal;
  exec_result.added_to_corpus = false;
  exec_result.found_unique_features = 0u;
  if (afl_coverage) {
    executor[executor_index].GetAFLFeedback().ShowMemoryToFunc(
        [&](const u8 *head, u32 size) {
          cov.assign(head, std::next(head, size));
        });
  } else {
    executor[executor_index].GetBBFeedback().ShowMemoryToFunc(
        [&](const u8 *head, u32 size) {
          cov.assign(head, std::next(head, size));
        });
  }
  output = executor[executor_index].MoveStdOut();
  auto err = executor[executor_index].MoveStdErr();
  output.insert(output.end(), err.begin(), err.end());
}

/**
 * Run edecutable, then retrive generated files
 *
 * @tparam Range Contiguous Range of std::uint8_t to pass input.
 * @tparam Output Container of std::uint8_t to receive standard output.
 * @tparam InputInfo Type of execution result.
 * @tparam Executor Executor type.
 * @param range The value passed to the process using executor defined method.
 * @param output Reference to container to receive standard output and standard
 * error generated by the process.
 * @param exec_result Reference to execution result to receive output detail of
 * this execution.
 * @param executor Executor to run the executable.
 */
template <typename Range, typename Output, typename InputInfo,
          typename Executor>
auto Execute(Range &range, Output &output, output_files_t &files,
             InputInfo &exec_result, Executor &executor,
             std::size_t executor_index)
    -> std::enable_if_t<is_input_info_v<InputInfo> &&
                        utils::range::is_range_of_v<Range, std::uint8_t> &&
                        utils::range::has_data_v<Range> &&
                        utils::range::is_range_of_v<Output, std::uint8_t>> {
  const auto begin = std::chrono::high_resolution_clock::now();
  executor[executor_index].Run(range.data(),
                               fuzzuf::utils::range::rangeSize(range));
  const auto end = std::chrono::high_resolution_clock::now();
  exec_result.enabled = true;
  exec_result.time_of_unit =
      std::chrono::duration_cast<std::chrono::microseconds>(end - begin);
  exec_result.status =
      executor[executor_index].GetExitStatusFeedback().exit_reason;
  exec_result.signal = executor[executor_index].GetExitStatusFeedback().signal;
  exec_result.added_to_corpus = false;
  exec_result.found_unique_features = 0u;
  auto files_ = (executor[executor_index].Filesystem() |
                 fuzzuf::utils::vfs::adaptor::read_once)
                    .MmapAll();
  for (auto &f : files_) {
    files.push_back(std::move(f.second));
  }
  output = executor[executor_index].MoveStdOut();
  auto err = executor[executor_index].MoveStdErr();
  output.insert(output.end(), err.begin(), err.end());
}

}  // namespace fuzzuf::algorithm::libfuzzer::executor

#endif
